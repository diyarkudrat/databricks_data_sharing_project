import { loadConfig } from '../config';
import { listDataSources } from './dataSourcesService';

const config = loadConfig();

// Helper to get headers
const getHeaders = () => ({
  Authorization: `Bearer ${config.databricksToken}`,
  'Content-Type': 'application/json',
});

// Helper to get base URL (removes trailing slash if present)
const getBaseUrl = () => {
  const host = config.databricksHost.replace(/\/$/, '');
  // Ensure protocol
  if (!host.startsWith('http')) {
    return `https://${host}`;
  }
  return host;
};

export interface JobRunResult {
  run_id: number;
  number_in_job: number;
}

export interface RunStatus {
  run_id: number;
  state: {
    life_cycle_state: 'PENDING' | 'RUNNING' | 'TERMINATING' | 'TERMINATED' | 'SKIPPED' | 'INTERNAL_ERROR';
    result_state?: 'SUCCESS' | 'FAILED' | 'TIMEDOUT' | 'CANCELED';
    state_message?: string;
  };
  task_id?: string;
  tasks?: Array<{
    run_id: number;
    task_key: string;
    state: {
      life_cycle_state: string;
      result_state: string;
      state_message: string;
    };
  }>;
}

export interface JobListResponse {
  jobs: Array<{
    job_id: number;
    settings: {
      name: string;
    };
  }>;
}

export interface JobCreateResponse {
  job_id: number;
}

/**
 * Lists jobs with optional name filter.
 * API: GET /api/2.1/jobs/list
 */
export async function listJobs(name: string): Promise<number | null> {
  const url = `${getBaseUrl()}/api/2.1/jobs/list?name=${encodeURIComponent(name)}`;
  
  const response = await fetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });

  if (!response.ok) {
    // If 404/empty list logic handled by API? Usually returns { jobs: [] }
    const errorText = await response.text();
    throw new Error(`Failed to list jobs: ${response.status} ${response.statusText} - ${errorText}`);
  }

  const data = (await response.json()) as JobListResponse;
  if (data.jobs && data.jobs.length > 0) {
    // Return the first match
    return data.jobs[0].job_id;
  }
  return null;
}

/**
 * Creates a new Databricks Job.
 * API: POST /api/2.1/jobs/create
 */
export async function createJob(name: string, warehouseId: string, sqlQuery: string): Promise<number> {
  // Legacy stub - we use createSqlJob below
  throw new Error("Use createSqlJob instead");
}

/**
 * REVISED CREATE JOB - We need to create a query first.
 */
export async function createSqlJob(name: string, warehouseId: string, sqlText: string): Promise<number> {
    // 1. Create the Query object
    const queryId = await createSqlQuery(name, warehouseId, sqlText);

    // 2. Create the Job
    const url = `${getBaseUrl()}/api/2.1/jobs/create`;
    const payload = {
        name,
        tasks: [
            {
                task_key: "export_task",
                sql_task: {
                    query: {
                        query_id: queryId
                    },
                    warehouse_id: warehouseId,
                    parameters: {
                        // Use Databricks dynamic job run ID for query substitution
                        run_id: "{{job.run_id}}"
                    }
                }
            }
        ],
        parameters: [
            {
                name: "run_id",
                default: "manual_test"
            }
        ]
    };

    const response = await fetch(url, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
        const txt = await response.text();
        throw new Error(`Failed to create job: ${txt}`);
    }

    const data = (await response.json()) as JobCreateResponse;
    return data.job_id;
}

async function createSqlQuery(name: string, warehouseId: string, query: string): Promise<string> {
    // Resolve the correct data_source_id (UUID) for the given warehouseId (16 chars)
    let dataSourceId = warehouseId;
    
    try {
        const dataSources = await listDataSources();
        // Look for a match where warehouse_id matches
        const match = dataSources.find(ds => ds.warehouse_id === warehouseId);
        if (match) {
            console.log(`[Jobs] Resolved warehouse ${warehouseId} to data source ${match.id}`);
            dataSourceId = match.id;
        } else {
            console.warn(`[Jobs] Could not find data source for warehouse ${warehouseId}. Available sources:`, dataSources.map(d => `${d.name}=${d.warehouse_id}`));
            // Optional: check if the input was ALREADY a UUID (length check)
            // But here we know it was 16 chars.
        }
    } catch (err) {
        console.warn("[Jobs] Failed to list data sources for ID resolution:", err);
    }

    const url = `${getBaseUrl()}/api/2.0/preview/sql/queries`;
    const payload = {
        name,
        data_source_id: dataSourceId,
        query,
        description: "Auto-generated by Dataporto Sync"
    };
    
    const response = await fetch(url, {
        method: 'POST',
        headers: getHeaders(),
        body: JSON.stringify(payload)
    });

    if (!response.ok) {
         const txt = await response.text();
         throw new Error(`Failed to create SQL Query object: ${txt}`);
    }
    
    const data = await response.json();
    return data.id;
}


/**
 * Triggers a specific Databricks Job to run immediately.
 * API: POST /api/2.1/jobs/run-now
 */
export async function triggerJob(jobId: string, params?: Record<string, string>): Promise<JobRunResult> {
  const url = `${getBaseUrl()}/api/2.1/jobs/run-now`;
  
  const body: any = { job_id: jobId };
  if (params) {
    body.job_parameters = params;
  }

  const response = await fetch(url, {
    method: 'POST',
    headers: getHeaders(),
    body: JSON.stringify(body),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to trigger job ${jobId}: ${response.status} ${response.statusText} - ${errorText}`);
  }

  const data = await response.json();
  return data as JobRunResult;
}

/**
 * Gets the status of a specific Job Run.
 * API: GET /api/2.1/jobs/runs/get?run_id=<run_id>
 */
export async function getRunStatus(runId: string): Promise<RunStatus> {
  const url = `${getBaseUrl()}/api/2.1/jobs/runs/get?run_id=${runId}`;
  
  const response = await fetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Failed to get run status for ${runId}: ${response.status} ${response.statusText} - ${errorText}`);
  }

  const data = await response.json();
  return data as RunStatus;
}

/**
 * Gets the output of a specific Job Run.
 * API: GET /api/2.1/jobs/runs/get-output?run_id=<run_id>
 */
export async function getRunOutput(runId: string): Promise<any> {
  const url = `${getBaseUrl()}/api/2.1/jobs/runs/get-output?run_id=${runId}`;

  const response = await fetch(url, {
    method: 'GET',
    headers: getHeaders(),
  });

  if (!response.ok) {
    const errorText = await response.text();
    // We don't want to throw here if we can't get output, just return generic error or null
    console.warn(`Failed to get run output for ${runId}: ${response.status} ${response.statusText}`);
    return { error: errorText };
  }

  return await response.json();
}
